<?xml version="1.0" encoding="utf-8" ?>

<!-- Nant style build file for #ZipLib -->

<project name="#ZipLib"	default="build" basedir="." >

	<!-- Setup Properties -->
	<property name="debug" value="false"/>
	<property name="optimize" value="true"/>
	<property name="checked" value="false" />
	<property name="version" value="0.85.2"/>
	<property name="build.output.dir" value="bin" />
	<property name="sharpziplib.name" value="ICSharpCode.SharpZipLib.dll" />
	<property name="build.sharpziplib.path" value="${build.output.dir}/${sharpziplib.name}" />

	<!-- Definitions to pass to compiler for compact framework -->
	<property name="build.cf.defines.v1" value="COMPACT_FRAMEWORK_V10" />
	<property name="build.cf.defines.v2" value="COMPACT_FRAMEWORK_V20" />

	<!-- System dependant properties.  These may need adjusting for your machine -->
	<property name="cf.path.v1.2005" value="${environment::get-variable('ProgramFiles')}/Microsoft Visual Studio 8/SmartDevices/SDK/CompactFramework/2.0/v1.0/WindowsCE" />
	<property name="cf.path.v2.2005" value="${environment::get-variable('ProgramFiles')}/Microsoft Visual Studio 8/SmartDevices/SDK/CompactFramework/2.0/v2.0/WindowsCE" />
	<property name="cf.path.v1.2003" value="${environment::get-variable('ProgramFiles')}/Microsoft Visual Studio .NET 2003/CompactFrameworkSDK/v1.0.5000/Windows CE" />
	
	<!-- Choose properties for actual build here -->
	<property name="build.cf.defines" value="${build.cf.defines.v1}" />
	<property name="cf.path" value="${cf.path.v1.2003}" />
	<property name="release.output.dir" value="bin/release" />

	<target
		name="build"
		depends="build.run"
		description="Build the current source."
	/>

	<target
		name="build_cf"
		depends="build_cf.run"
		description="Build for compact framework. Version defined in build.cf.defines property"
	/>

	<target name="rebuild"
		description="Clean and rebuild"
		depends="clean, build"
	/>

	<target 
		name="clean"
		depends="clean.run"
		description="Remove build artefacts"
	/>

	<target
		name="test"
		depends="test.run"
		description="Run unit tests"
	/>

	<target
		name="preparerelease"
		depends="preparerelease.run"
		description="Prepare for a release." 
	/>

	<!-- Low level internal subtargets -->
	<target
		name="build.run"
		depends="build.run.desktop"
	/>

	<target
		name="release.run" >
<!-- Speculative notes more than real working build.  A lot to sort out.
		<call target="preparerelease" />
		<delete dir="${release.output.dir}" if="${directory::exists('${release.output.dir}')}" />
		<mkdir dir="${release.output.dir}" />
		<call target="clean" />
		<call target="build.run.desktop" />
		<zip zipfile="${release.output.dir}/ICSharpCode.SharpZipLib_11.zip" >
			<fileset basedir="${build.output.dir}">
				<include name="${build.target.name}" />
			</fileset>
		</zip>
		<call target="clean" />
-->

		<echo message="release building is not working" />
	</target>

	<target name="clean.run">
		<delete verbose="true" >
			<fileset basedir=".">
				<include name="${build.output.dir}/ICSharpCode.SharpZipLib.dll"/>
				<include name="${build.output.dir}/ICSharpCode.SharpZipLib.pdb"/>
			</fileset>
		</delete>
		<nant buildfile = "samples/cs/samples.build" target="clean"/>
		<nant buildfile = "samples/vb/samples.build" target="clean"/>
		<nant buildfile = "tests/tests.build" target="clean"/>
	</target>

	<target
		name="test.run"
		depends="build" >
		<nant buildfile="tests/tests.build" target="test"/>
	</target>

	<target name="build.run.desktop" >
		<echo message="Building #ZipLib"/>
		<csc 
			target="library" 
			output="${build.sharpziplib.path}" 
			optimize="${optimize}"
			debug="${debug}"
			checked="${checked}"
			platform="anycpu"
			keyfile="ICSharpCode.SharpZipLib.key"
		>
			
			<sources basedir="src">
				<include name="**/*.cs"/>
			</sources>
		</csc>
		<nant buildfile = "samples/cs/samples.build" />
		<nant buildfile = "samples/vb/samples.build" />
	</target>

	<target name="build_cf.run">
		<echo message="Building #ZipLib for compact framework"/>
		<csc 
			target="library" 
			output="${build.sharpziplib.path}" 
			optimize="${optimize}"
			debug="${debug}"
			nostdlib="true"
			noconfig="true"
			checked="${checked}"
			define="${build.cf.defines}"
			keyfile="ICSharpCode.SharpZipLib.key"
		>
			<sources basedir="src">
				<include name="**/*.cs"/>
			</sources>
			<references>
				<include name="${cf.path}/mscorlib.dll"/>
				<include name="${cf.path}/system.dll"/>
			</references>
		</csc>
	</target>

	<target name="preparerelease.run" >

		<script language="C#">
			<code><![CDATA[
		static StringCollection SearchDirectory(string directory, string filemask)
		{
			StringCollection collection = new StringCollection();
			SearchDirectory(directory, filemask, collection);
			return collection;
		}
		
		static void SearchDirectory(string directory, string filemask, StringCollection collection)
		{
			try {
				string[] file = Directory.GetFiles(directory, filemask);
				foreach (string f in file) {
					collection.Add(f);
				}
				
				string[] dir = Directory.GetDirectories(directory);
				foreach (string d in dir) {
					SearchDirectory(d, filemask, collection);
				}
			} catch (Exception) {
			}
		}
		
		static Regex AssemblyVersion = new Regex("AssemblyVersion\\(.*\\)]");
		static void SetVersionInfo(string fileName, string version)
		{
			StreamReader inFile = null;
			string       content;
			
			try {
				inFile  = new StreamReader(fileName);
				content = inFile.ReadToEnd();
			} catch (Exception e) {
				Console.WriteLine(e);
				return;
			} finally {
				if (inFile != null) {
					inFile.Close();
				}
			}
			
			if (content != null) {
				string newContent = AssemblyVersion.Replace(content, "AssemblyVersion(\"" + version + "\")]");
				StreamWriter outFile = null;
				try {
					outFile = new StreamWriter(fileName);
					outFile.Write(newContent);
				} catch (Exception e) {
					Console.WriteLine(e);
					return;
				} finally {
					if (outFile != null) {
						outFile.Close();
					}
				}
			}
		}
		
		static string revisionNumber = "0";
		static string ReadRevisionFromFile()
		{
			try {
				StreamReader reader = new StreamReader(@"REVISION");
				using (reader) {
					return reader.ReadLine();
				}
			}
			catch (Exception e) {
				Console.WriteLine(e.Message);
				throw new Exception("Cannot read revision number from file: " + e.Message);
			}
		}
		static void RetrieveRevisionNumber()
		{
			try {
				System.Diagnostics.ProcessStartInfo psi = new System.Diagnostics.ProcessStartInfo("svn", "info");
				psi.UseShellExecute = false;
				psi.RedirectStandardOutput = true;
				
				try {
					System.Diagnostics.Process process = System.Diagnostics.Process.Start(psi);
					process.WaitForExit();
					string output = process.StandardOutput.ReadToEnd();
					
					Regex r = new Regex(@"Revision:\s+(\d+)");
					Match m = r.Match(output);
					if (m != null && m.Success && m.Groups[1] != null) {
						revisionNumber = m.Groups[1].Value;
						Console.WriteLine("SVN Version '{0}'", revisionNumber);
					}
					if ((revisionNumber == null) || revisionNumber.Equals("") || revisionNumber.Equals("0")) {
						throw new Exception("Could not find revision number in svn output");
					}
				} catch (Exception e) {
					revisionNumber = ReadRevisionFromFile();
					Console.WriteLine("Exception retrieving SVN revision - {0} using revision {1}", e.Message, revisionNumber);
				}
			} catch {
			}
		}

		static void SetVersion(string directory, string version)
		{
			StringCollection col = SearchDirectory(directory, "AssemblyInfo.cs");
			string[] dontTouchList = new string[] { 
				"samples/HttpCompressionModule/src/AssemblyInfo.cs",
				"samples/DIME/DimeDataSetService/AssemblyInfo.cs",
				"samples/DIME/DimeDataSetServiceConsumer/AssemblyInfo.cs",
				};
			string versionNumber = version + "." + revisionNumber;
			foreach (string fileName in col) {
				bool doSetVersion = true;
				foreach (string dontTouch in dontTouchList) {
					if (fileName.EndsWith(dontTouch.Replace("/", Path.DirectorySeparatorChar.ToString()))) {
						doSetVersion = false;
						break;
					}
				}
				if (doSetVersion) {
					Console.WriteLine("set revision to file : " + fileName + " to " + versionNumber);
					SetVersionInfo(fileName, versionNumber);
				}
			}
		}
		
		public static void ScriptMain(Project project) 
		{
			RetrieveRevisionNumber();
			SetVersion(".", project.Properties["version"].ToString());
		}
			]]></code>
		</script>
	</target>
	
</project>
